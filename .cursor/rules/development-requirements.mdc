---
description: 
globs: 
alwaysApply: false
---
# Development Requirements

## Overview

Core development requirements and standards for Next.js 14 applications.

<rule>
name: development_requirements
description: Development requirements and standards for Next.js 14 applications
version: 1.0.0
author: Development Team
date: 2024-01-01
globs: ["app/**/*", "components/**/*", "pages/**/*"]
tags:
  - nextjs
  - react
  - typescript
  - development
</rule>

## 1. Core Requirements

1. Do not delete existing functionality unless necessary
2. Use App Router: All components within `app` directory
3. Implement Server Components by default
4. Use modern TypeScript syntax
5. Follow responsive design with Tailwind CSS
6. Create modular, reusable components
7. Efficient data fetching with server components
8. Use Next.js 14's metadata API for SEO
9. Use Next.js Image component
10. Ensure accessibility with ARIA
11. Use error.tsx for error handling
12. Use loading.tsx for loading states
13. Use route.ts for API routes
14. Implement SSG/SSR appropriately
15. Focus only on task-related changes
16. Use components over in-line html. If a component doesn't exist, check shadcn for it. If it doesn't exist there, create it.

## 2. Code Standards

### 2.1 Client Components

```tsx
"use client";
const ComponentName = () => {
  // Component logic
};
```

### 2.2 Props Interface

```tsx
interface ComponentNameProps {
  // Props definition
}
const ComponentName = ({ prop1, prop2 }: ComponentNameProps) => {
  // Component logic
};
```

### 2.3 Server Components

```tsx
async function getData() {
  const res = await fetch("https://api.example.com/data", {
    next: { revalidate: 3600 },
  });
  if (!res.ok) throw new Error("Failed to fetch data");
  return res.json();
}
```

### 2.4 Type Documentation

```typescript
/**
 * Clear description of the type's purpose and context.
 * Include any important notes about usage or constraints.
 */
export interface ExampleType {
  /** Description with value range if applicable (e.g., 0-1) */
  numericField: number;
  /** Description of what this field represents */
  stringField: string;
  /** Object field description */
  objectField: {
    /** Nested field description */
    nestedField: string;
  };
}
```

## 3. Type Documentation Rules

- Every exported type must have a JSDoc comment explaining its purpose
- Each field must have an inline JSDoc comment
- Include value ranges for numeric fields (e.g., 0-1, 0-100)
- Document optional fields and their implications
- Explain relationships with other types
- Note any validation requirements
- Document any default values
- Include usage examples for complex types

## 4. Component Guidelines

### 4.1 Component Structure

- Use functional components with hooks
- Implement proper TypeScript interfaces
- Follow naming conventions
- Use proper file extensions (.tsx for components)
- Organize imports logically

### 4.2 State Management

- Use React hooks for local state
- Use Zustand for global state
- Avoid prop drilling
- Use context sparingly
- Implement proper error boundaries

### 4.3 Performance

- Use React.memo for expensive components
- Implement proper dependency arrays
- Use useMemo and useCallback appropriately
- Optimize bundle size
- Implement proper loading states

## 5. File Organization

### 5.1 Directory Structure

```
/app/
├── actions/               # Server actions
├── api/                  # API routes
├── components/           # UI components
│   ├── blocks/          # Content blocks
│   └── ui/              # shadcn/UI components
├── config/              # Configuration
├── constants/           # Constants
├── hooks/               # React hooks
├── services/            # Business logic
├── stores/              # State management
├── types/               # TypeScript types
└── utils/               # Utilities
```

### 5.2 Naming Conventions

- Components: PascalCase (e.g., `UserProfile.tsx`)
- Files: kebab-case (e.g., `user-profile.tsx`)
- Functions: camelCase (e.g., `getUserData`)
- Constants: UPPER_SNAKE_CASE (e.g., `API_ENDPOINT`)
- Types: PascalCase (e.g., `UserProfileProps`)

## 6. Best Practices

### 6.1 Error Handling

- Use error boundaries for component errors
- Implement proper try-catch blocks
- Provide meaningful error messages
- Log errors appropriately
- Handle network errors gracefully

### 6.2 Accessibility

- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Provide alt text for images
- Test with screen readers

### 6.3 Testing

- Write unit tests for components
- Test user interactions
- Mock external dependencies
- Test error scenarios
- Maintain good test coverage

## 7. Development Workflow

### 7.1 Before Starting

- Review existing codebase
- Check for similar components
- Plan component structure
- Consider reusability
- Document requirements

### 7.2 During Development

- Follow TypeScript best practices
- Use proper error handling
- Implement loading states
- Test functionality
- Update documentation

### 7.3 Before Committing

- Run tests
- Check for linting errors
- Review code quality
- Update documentation
- Test in different environments
